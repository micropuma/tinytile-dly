// -----// IR Dump Before TutorialApplyTilingSpec (tutorial-apply-tiling-spec) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d6, d4, d5, d3)>
#map1 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1 + d4, d2 + d5, d6)>
#map2 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3)>
#map3 = affine_map<(d0, d1, d2, d3) -> ()>
#map4 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %0 = tutorial.dequant %arg0, %arg1 : tensor<5x82x102x128xf32>, tensor<5x82x102x128xf32>, tensor<5x82x102x128xf32>
    %1 = tensor.empty() : tensor<5x80x100x128xf32>
    %broadcasted = linalg.broadcast ins(%arg3 : tensor<128xf32>) outs(%1 : tensor<5x80x100x128xf32>) dimensions = [0, 1, 2] 
    %2 = linalg.generic {indexing_maps = [#map, #map1, #map2], iterator_types = ["parallel", "parallel", "parallel", "parallel", "reduction", "reduction", "reduction"]} ins(%arg2, %0 : tensor<128x3x3x128xf32>, tensor<5x82x102x128xf32>) outs(%broadcasted : tensor<5x80x100x128xf32>) attrs =  {lowering_config = {parallel = [1, 1, 5, 64], reduction = [0, 0, 0, 0, 1, 1, 1]}} {
    ^bb0(%in: f32, %in_0: f32, %out: f32):
      %4 = arith.mulf %in, %in_0 : f32
      %5 = arith.addf %out, %4 : f32
      linalg.yield %5 : f32
    } -> tensor<5x80x100x128xf32>
    %cst = arith.constant 0.000000e+00 : f32
    %3 = linalg.generic {indexing_maps = [#map3, #map4, #map4], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%cst, %2 : f32, tensor<5x80x100x128xf32>) outs(%arg4 : tensor<5x80x100x128xf32>) {
    ^bb0(%in: f32, %in_0: f32, %out: f32):
      %4 = arith.maxnumf %in, %in_0 : f32
      linalg.yield %4 : f32
    } -> tensor<5x80x100x128xf32>
    return %3 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before TutorialTileAndFuse (tutorial-tile-and-fuse) ('func.func' operation: @conv_with_dequant) //----- //
#map = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d6, d4, d5, d3)>
#map1 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1 + d4, d2 + d5, d6)>
#map2 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3)>
#map3 = affine_map<(d0, d1, d2, d3) -> ()>
#map4 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %0 = tutorial.dequant %arg0, %arg1 : tensor<5x82x102x128xf32>, tensor<5x82x102x128xf32>, tensor<5x82x102x128xf32>
    %1 = tensor.empty() : tensor<5x80x100x128xf32>
    %broadcasted = linalg.broadcast ins(%arg3 : tensor<128xf32>) outs(%1 : tensor<5x80x100x128xf32>) dimensions = [0, 1, 2] 
    %2 = linalg.generic {indexing_maps = [#map, #map1, #map2], iterator_types = ["parallel", "parallel", "parallel", "parallel", "reduction", "reduction", "reduction"]} ins(%arg2, %0 : tensor<128x3x3x128xf32>, tensor<5x82x102x128xf32>) outs(%broadcasted : tensor<5x80x100x128xf32>) attrs =  {lowering_config = {parallel = [1, 1, 5, 64], reduction = [0, 0, 0, 0, 1, 1, 1]}} {
    ^bb0(%in: f32, %in_0: f32, %out: f32):
      %4 = arith.mulf %in, %in_0 : f32
      %5 = arith.addf %out, %4 : f32
      linalg.yield %5 : f32
    } -> tensor<5x80x100x128xf32>
    %cst = arith.constant 0.000000e+00 : f32
    %3 = linalg.generic {indexing_maps = [#map3, #map4, #map4], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%cst, %2 : f32, tensor<5x80x100x128xf32>) outs(%arg4 : tensor<5x80x100x128xf32>) {
    ^bb0(%in: f32, %in_0: f32, %out: f32):
      %4 = arith.maxnumf %in, %in_0 : f32
      linalg.yield %4 : f32
    } -> tensor<5x80x100x128xf32>
    return %3 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump After TutorialTileAndFuse (tutorial-tile-and-fuse) ('func.func' operation: @conv_with_dequant) //----- //
#map = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d6, d4, d5, d3)>
#map1 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1 + d4, d2 + d5, d6)>
#map2 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3)>
#map3 = affine_map<(d0, d1, d2, d3) -> ()>
#map4 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %cst = arith.constant 0.000000e+00 : f32
    %0 = tensor.empty() : tensor<5x80x100x128xf32>
    %1:2 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %0, %arg10 = %arg4) -> (tensor<5x80x100x128xf32>, tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_0 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %2 = tutorial.dequant %extracted_slice_0, %extracted_slice_1 : tensor<1x3x7x128xf32>, tensor<1x3x7x128xf32>, tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %extracted_slice_3 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %broadcasted = linalg.broadcast ins(%extracted_slice_2 : tensor<64xf32>) outs(%extracted_slice_3 : tensor<1x1x5x64xf32>) dimensions = [0, 1, 2] 
      %3 = linalg.generic {indexing_maps = [#map, #map1, #map2], iterator_types = ["parallel", "parallel", "parallel", "parallel", "reduction", "reduction", "reduction"]} ins(%extracted_slice, %2 : tensor<128x3x3x64xf32>, tensor<1x3x7x128xf32>) outs(%broadcasted : tensor<1x1x5x64xf32>) attrs =  {lowering_config = {parallel = [1, 1, 5, 64], reduction = [0, 0, 0, 0, 1, 1, 1]}} {
      ^bb0(%in: f32, %in_5: f32, %out: f32):
        %5 = arith.mulf %in, %in_5 : f32
        %6 = arith.addf %out, %5 : f32
        linalg.yield %6 : f32
      } -> tensor<1x1x5x64xf32>
      %extracted_slice_4 = tensor.extract_slice %arg10[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %4 = linalg.generic {indexing_maps = [#map3, #map4, #map4], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%cst, %3 : f32, tensor<1x1x5x64xf32>) outs(%extracted_slice_4 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %in_5: f32, %out: f32):
        %5 = arith.maxnumf %in, %in_5 : f32
        linalg.yield %5 : f32
      } -> tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %3 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
        tensor.parallel_insert_slice %4 into %arg10[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %1#1 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before TutorialTileAndFuse (tutorial-tile-and-fuse) ('func.func' operation: @conv_with_dequant) //----- //
#map = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d6, d4, d5, d3)>
#map1 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1 + d4, d2 + d5, d6)>
#map2 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3)>
#map3 = affine_map<(d0, d1, d2, d3) -> ()>
#map4 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %cst = arith.constant 0.000000e+00 : f32
    %0 = tensor.empty() : tensor<5x80x100x128xf32>
    %1:2 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %0, %arg10 = %arg4) -> (tensor<5x80x100x128xf32>, tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_0 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %2 = tutorial.dequant %extracted_slice_0, %extracted_slice_1 : tensor<1x3x7x128xf32>, tensor<1x3x7x128xf32>, tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %extracted_slice_3 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %broadcasted = linalg.broadcast ins(%extracted_slice_2 : tensor<64xf32>) outs(%extracted_slice_3 : tensor<1x1x5x64xf32>) dimensions = [0, 1, 2] 
      %3 = linalg.generic {indexing_maps = [#map, #map1, #map2], iterator_types = ["parallel", "parallel", "parallel", "parallel", "reduction", "reduction", "reduction"]} ins(%extracted_slice, %2 : tensor<128x3x3x64xf32>, tensor<1x3x7x128xf32>) outs(%broadcasted : tensor<1x1x5x64xf32>) attrs =  {lowering_config = {parallel = [1, 1, 5, 64], reduction = [0, 0, 0, 0, 1, 1, 1]}} {
      ^bb0(%in: f32, %in_5: f32, %out: f32):
        %5 = arith.mulf %in, %in_5 : f32
        %6 = arith.addf %out, %5 : f32
        linalg.yield %6 : f32
      } -> tensor<1x1x5x64xf32>
      %extracted_slice_4 = tensor.extract_slice %arg10[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %4 = linalg.generic {indexing_maps = [#map3, #map4, #map4], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%cst, %3 : f32, tensor<1x1x5x64xf32>) outs(%extracted_slice_4 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %in_5: f32, %out: f32):
        %5 = arith.maxnumf %in, %in_5 : f32
        linalg.yield %5 : f32
      } -> tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %3 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
        tensor.parallel_insert_slice %4 into %arg10[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %1#1 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump After TutorialTileAndFuse (tutorial-tile-and-fuse) ('func.func' operation: @conv_with_dequant) //----- //
#map = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d6, d4, d5, d3)>
#map1 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1 + d4, d2 + d5, d6)>
#map2 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3)>
#map3 = affine_map<(d0, d1, d2, d3) -> ()>
#map4 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = tensor.empty() : tensor<5x80x100x128xf32>
    %1:2 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %0, %arg10 = %arg4) -> (tensor<5x80x100x128xf32>, tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_0 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %extracted_slice_3 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %broadcasted = linalg.broadcast ins(%extracted_slice_2 : tensor<64xf32>) outs(%extracted_slice_3 : tensor<1x1x5x64xf32>) dimensions = [0, 1, 2] 
      %2 = scf.for %arg11 = %c0 to %c3 step %c1 iter_args(%arg12 = %broadcasted) -> (tensor<1x1x5x64xf32>) {
        %4 = scf.for %arg13 = %c0 to %c3 step %c1 iter_args(%arg14 = %arg12) -> (tensor<1x1x5x64xf32>) {
          %5 = scf.for %arg15 = %c0 to %c128 step %c1 iter_args(%arg16 = %arg14) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_5 = tensor.extract_slice %extracted_slice[%arg15, %arg11, %arg13, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_6 = tensor.extract_slice %extracted_slice_0[0, %arg11, %arg13, %arg15] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_7 = tensor.extract_slice %extracted_slice_1[0, %arg11, %arg13, %arg15] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %6 = tutorial.dequant %extracted_slice_6, %extracted_slice_7 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %7 = linalg.generic {indexing_maps = [#map, #map1, #map2], iterator_types = ["parallel", "parallel", "parallel", "parallel", "reduction", "reduction", "reduction"]} ins(%extracted_slice_5, %6 : tensor<1x1x1x64xf32>, tensor<1x1x5x1xf32>) outs(%arg16 : tensor<1x1x5x64xf32>) attrs =  {lowering_config = {parallel = [1, 1, 5, 64], reduction = [0, 0, 0, 0, 1, 1, 1]}} {
            ^bb0(%in: f32, %in_8: f32, %out: f32):
              %8 = arith.mulf %in, %in_8 : f32
              %9 = arith.addf %out, %8 : f32
              linalg.yield %9 : f32
            } -> tensor<1x1x5x64xf32>
            scf.yield %7 : tensor<1x1x5x64xf32>
          }
          scf.yield %5 : tensor<1x1x5x64xf32>
        }
        scf.yield %4 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_4 = tensor.extract_slice %arg10[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %3 = linalg.generic {indexing_maps = [#map3, #map4, #map4], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%cst, %2 : f32, tensor<1x1x5x64xf32>) outs(%extracted_slice_4 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %in_5: f32, %out: f32):
        %4 = arith.maxnumf %in, %in_5 : f32
        linalg.yield %4 : f32
      } -> tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %2 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
        tensor.parallel_insert_slice %3 into %arg10[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %1#1 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before LinalgGeneralizeNamedOpsPass (linalg-generalize-named-ops) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d6, d4, d5, d3)>
#map1 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1 + d4, d2 + d5, d6)>
#map2 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3)>
#map3 = affine_map<(d0, d1, d2, d3) -> ()>
#map4 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = tensor.empty() : tensor<5x80x100x128xf32>
    %1:2 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %0, %arg10 = %arg4) -> (tensor<5x80x100x128xf32>, tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_0 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %extracted_slice_3 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %broadcasted = linalg.broadcast ins(%extracted_slice_2 : tensor<64xf32>) outs(%extracted_slice_3 : tensor<1x1x5x64xf32>) dimensions = [0, 1, 2] 
      %2 = scf.for %arg11 = %c0 to %c3 step %c1 iter_args(%arg12 = %broadcasted) -> (tensor<1x1x5x64xf32>) {
        %4 = scf.for %arg13 = %c0 to %c3 step %c1 iter_args(%arg14 = %arg12) -> (tensor<1x1x5x64xf32>) {
          %5 = scf.for %arg15 = %c0 to %c128 step %c1 iter_args(%arg16 = %arg14) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_5 = tensor.extract_slice %extracted_slice[%arg15, %arg11, %arg13, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_6 = tensor.extract_slice %extracted_slice_0[0, %arg11, %arg13, %arg15] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_7 = tensor.extract_slice %extracted_slice_1[0, %arg11, %arg13, %arg15] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %6 = tutorial.dequant %extracted_slice_6, %extracted_slice_7 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %7 = linalg.generic {indexing_maps = [#map, #map1, #map2], iterator_types = ["parallel", "parallel", "parallel", "parallel", "reduction", "reduction", "reduction"]} ins(%extracted_slice_5, %6 : tensor<1x1x1x64xf32>, tensor<1x1x5x1xf32>) outs(%arg16 : tensor<1x1x5x64xf32>) attrs =  {lowering_config = {parallel = [1, 1, 5, 64], reduction = [0, 0, 0, 0, 1, 1, 1]}} {
            ^bb0(%in: f32, %in_8: f32, %out: f32):
              %8 = arith.mulf %in, %in_8 : f32
              %9 = arith.addf %out, %8 : f32
              linalg.yield %9 : f32
            } -> tensor<1x1x5x64xf32>
            scf.yield %7 : tensor<1x1x5x64xf32>
          }
          scf.yield %5 : tensor<1x1x5x64xf32>
        }
        scf.yield %4 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_4 = tensor.extract_slice %arg10[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %3 = linalg.generic {indexing_maps = [#map3, #map4, #map4], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%cst, %2 : f32, tensor<1x1x5x64xf32>) outs(%extracted_slice_4 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %in_5: f32, %out: f32):
        %4 = arith.maxnumf %in, %in_5 : f32
        linalg.yield %4 : f32
      } -> tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %2 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
        tensor.parallel_insert_slice %3 into %arg10[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %1#1 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump After LinalgGeneralizeNamedOpsPass (linalg-generalize-named-ops) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d3)>
#map1 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
#map2 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d6, d4, d5, d3)>
#map3 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1 + d4, d2 + d5, d6)>
#map4 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3)>
#map5 = affine_map<(d0, d1, d2, d3) -> ()>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = tensor.empty() : tensor<5x80x100x128xf32>
    %1:2 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %0, %arg10 = %arg4) -> (tensor<5x80x100x128xf32>, tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_0 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %extracted_slice_3 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %2 = linalg.generic {indexing_maps = [#map, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%extracted_slice_2 : tensor<64xf32>) outs(%extracted_slice_3 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %out: f32):
        linalg.yield %in : f32
      } -> tensor<1x1x5x64xf32>
      %3 = scf.for %arg11 = %c0 to %c3 step %c1 iter_args(%arg12 = %2) -> (tensor<1x1x5x64xf32>) {
        %5 = scf.for %arg13 = %c0 to %c3 step %c1 iter_args(%arg14 = %arg12) -> (tensor<1x1x5x64xf32>) {
          %6 = scf.for %arg15 = %c0 to %c128 step %c1 iter_args(%arg16 = %arg14) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_5 = tensor.extract_slice %extracted_slice[%arg15, %arg11, %arg13, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_6 = tensor.extract_slice %extracted_slice_0[0, %arg11, %arg13, %arg15] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_7 = tensor.extract_slice %extracted_slice_1[0, %arg11, %arg13, %arg15] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %7 = tutorial.dequant %extracted_slice_6, %extracted_slice_7 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %8 = linalg.generic {indexing_maps = [#map2, #map3, #map4], iterator_types = ["parallel", "parallel", "parallel", "parallel", "reduction", "reduction", "reduction"]} ins(%extracted_slice_5, %7 : tensor<1x1x1x64xf32>, tensor<1x1x5x1xf32>) outs(%arg16 : tensor<1x1x5x64xf32>) attrs =  {lowering_config = {parallel = [1, 1, 5, 64], reduction = [0, 0, 0, 0, 1, 1, 1]}} {
            ^bb0(%in: f32, %in_8: f32, %out: f32):
              %9 = arith.mulf %in, %in_8 : f32
              %10 = arith.addf %out, %9 : f32
              linalg.yield %10 : f32
            } -> tensor<1x1x5x64xf32>
            scf.yield %8 : tensor<1x1x5x64xf32>
          }
          scf.yield %6 : tensor<1x1x5x64xf32>
        }
        scf.yield %5 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_4 = tensor.extract_slice %arg10[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %4 = linalg.generic {indexing_maps = [#map5, #map1, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%cst, %3 : f32, tensor<1x1x5x64xf32>) outs(%extracted_slice_4 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %in_5: f32, %out: f32):
        %5 = arith.maxnumf %in, %in_5 : f32
        linalg.yield %5 : f32
      } -> tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %3 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
        tensor.parallel_insert_slice %4 into %arg10[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %1#1 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d3)>
#map1 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
#map2 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d6, d4, d5, d3)>
#map3 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1 + d4, d2 + d5, d6)>
#map4 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3)>
#map5 = affine_map<(d0, d1, d2, d3) -> ()>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = tensor.empty() : tensor<5x80x100x128xf32>
    %1:2 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %0, %arg10 = %arg4) -> (tensor<5x80x100x128xf32>, tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_0 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %extracted_slice_3 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %2 = linalg.generic {indexing_maps = [#map, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%extracted_slice_2 : tensor<64xf32>) outs(%extracted_slice_3 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %out: f32):
        linalg.yield %in : f32
      } -> tensor<1x1x5x64xf32>
      %3 = scf.for %arg11 = %c0 to %c3 step %c1 iter_args(%arg12 = %2) -> (tensor<1x1x5x64xf32>) {
        %5 = scf.for %arg13 = %c0 to %c3 step %c1 iter_args(%arg14 = %arg12) -> (tensor<1x1x5x64xf32>) {
          %6 = scf.for %arg15 = %c0 to %c128 step %c1 iter_args(%arg16 = %arg14) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_5 = tensor.extract_slice %extracted_slice[%arg15, %arg11, %arg13, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_6 = tensor.extract_slice %extracted_slice_0[0, %arg11, %arg13, %arg15] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_7 = tensor.extract_slice %extracted_slice_1[0, %arg11, %arg13, %arg15] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %7 = tutorial.dequant %extracted_slice_6, %extracted_slice_7 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %8 = linalg.generic {indexing_maps = [#map2, #map3, #map4], iterator_types = ["parallel", "parallel", "parallel", "parallel", "reduction", "reduction", "reduction"]} ins(%extracted_slice_5, %7 : tensor<1x1x1x64xf32>, tensor<1x1x5x1xf32>) outs(%arg16 : tensor<1x1x5x64xf32>) attrs =  {lowering_config = {parallel = [1, 1, 5, 64], reduction = [0, 0, 0, 0, 1, 1, 1]}} {
            ^bb0(%in: f32, %in_8: f32, %out: f32):
              %9 = arith.mulf %in, %in_8 : f32
              %10 = arith.addf %out, %9 : f32
              linalg.yield %10 : f32
            } -> tensor<1x1x5x64xf32>
            scf.yield %8 : tensor<1x1x5x64xf32>
          }
          scf.yield %6 : tensor<1x1x5x64xf32>
        }
        scf.yield %5 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_4 = tensor.extract_slice %arg10[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %4 = linalg.generic {indexing_maps = [#map5, #map1, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%cst, %3 : f32, tensor<1x1x5x64xf32>) outs(%extracted_slice_4 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %in_5: f32, %out: f32):
        %5 = arith.maxnumf %in, %in_5 : f32
        linalg.yield %5 : f32
      } -> tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %3 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
        tensor.parallel_insert_slice %4 into %arg10[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %1#1 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d3)>
#map1 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
#map2 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d6, d4, d5, d3)>
#map3 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1 + d4, d2 + d5, d6)>
#map4 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3)>
#map5 = affine_map<(d0, d1, d2, d3) -> ()>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = tensor.empty() : tensor<5x80x100x128xf32>
    %1 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_0 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %extracted_slice_3 = tensor.extract_slice %0[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %2 = linalg.generic {indexing_maps = [#map, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%extracted_slice_2 : tensor<64xf32>) outs(%extracted_slice_3 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %out: f32):
        linalg.yield %in : f32
      } -> tensor<1x1x5x64xf32>
      %3 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %2) -> (tensor<1x1x5x64xf32>) {
        %5 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (tensor<1x1x5x64xf32>) {
          %6 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_5 = tensor.extract_slice %extracted_slice[%arg14, %arg10, %arg12, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_6 = tensor.extract_slice %extracted_slice_0[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_7 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %7 = tutorial.dequant %extracted_slice_6, %extracted_slice_7 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %8 = linalg.generic {indexing_maps = [#map2, #map3, #map4], iterator_types = ["parallel", "parallel", "parallel", "parallel", "reduction", "reduction", "reduction"]} ins(%extracted_slice_5, %7 : tensor<1x1x1x64xf32>, tensor<1x1x5x1xf32>) outs(%arg15 : tensor<1x1x5x64xf32>) attrs =  {lowering_config = {parallel = [1, 1, 5, 64], reduction = [0, 0, 0, 0, 1, 1, 1]}} {
            ^bb0(%in: f32, %in_8: f32, %out: f32):
              %9 = arith.mulf %in, %in_8 : f32
              %10 = arith.addf %out, %9 : f32
              linalg.yield %10 : f32
            } -> tensor<1x1x5x64xf32>
            scf.yield %8 : tensor<1x1x5x64xf32>
          }
          scf.yield %6 : tensor<1x1x5x64xf32>
        }
        scf.yield %5 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_4 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %4 = linalg.generic {indexing_maps = [#map5, #map1, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%cst, %3 : f32, tensor<1x1x5x64xf32>) outs(%extracted_slice_4 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %in_5: f32, %out: f32):
        %5 = arith.maxnumf %in, %in_5 : f32
        linalg.yield %5 : f32
      } -> tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %4 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %1 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before CSE (cse) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d3)>
#map1 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
#map2 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d6, d4, d5, d3)>
#map3 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1 + d4, d2 + d5, d6)>
#map4 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3)>
#map5 = affine_map<(d0, d1, d2, d3) -> ()>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = tensor.empty() : tensor<5x80x100x128xf32>
    %1 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_0 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %extracted_slice_3 = tensor.extract_slice %0[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %2 = linalg.generic {indexing_maps = [#map, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%extracted_slice_2 : tensor<64xf32>) outs(%extracted_slice_3 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %out: f32):
        linalg.yield %in : f32
      } -> tensor<1x1x5x64xf32>
      %3 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %2) -> (tensor<1x1x5x64xf32>) {
        %5 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (tensor<1x1x5x64xf32>) {
          %6 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_5 = tensor.extract_slice %extracted_slice[%arg14, %arg10, %arg12, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_6 = tensor.extract_slice %extracted_slice_0[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_7 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %7 = tutorial.dequant %extracted_slice_6, %extracted_slice_7 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %8 = linalg.generic {indexing_maps = [#map2, #map3, #map4], iterator_types = ["parallel", "parallel", "parallel", "parallel", "reduction", "reduction", "reduction"]} ins(%extracted_slice_5, %7 : tensor<1x1x1x64xf32>, tensor<1x1x5x1xf32>) outs(%arg15 : tensor<1x1x5x64xf32>) attrs =  {lowering_config = {parallel = [1, 1, 5, 64], reduction = [0, 0, 0, 0, 1, 1, 1]}} {
            ^bb0(%in: f32, %in_8: f32, %out: f32):
              %9 = arith.mulf %in, %in_8 : f32
              %10 = arith.addf %out, %9 : f32
              linalg.yield %10 : f32
            } -> tensor<1x1x5x64xf32>
            scf.yield %8 : tensor<1x1x5x64xf32>
          }
          scf.yield %6 : tensor<1x1x5x64xf32>
        }
        scf.yield %5 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_4 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %4 = linalg.generic {indexing_maps = [#map5, #map1, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%cst, %3 : f32, tensor<1x1x5x64xf32>) outs(%extracted_slice_4 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %in_5: f32, %out: f32):
        %5 = arith.maxnumf %in, %in_5 : f32
        linalg.yield %5 : f32
      } -> tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %4 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %1 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before LoopInvariantCodeMotion (loop-invariant-code-motion) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d3)>
#map1 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
#map2 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d6, d4, d5, d3)>
#map3 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1 + d4, d2 + d5, d6)>
#map4 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3)>
#map5 = affine_map<(d0, d1, d2, d3) -> ()>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = tensor.empty() : tensor<5x80x100x128xf32>
    %1 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_0 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %extracted_slice_3 = tensor.extract_slice %0[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %2 = linalg.generic {indexing_maps = [#map, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%extracted_slice_2 : tensor<64xf32>) outs(%extracted_slice_3 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %out: f32):
        linalg.yield %in : f32
      } -> tensor<1x1x5x64xf32>
      %3 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %2) -> (tensor<1x1x5x64xf32>) {
        %5 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (tensor<1x1x5x64xf32>) {
          %6 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_5 = tensor.extract_slice %extracted_slice[%arg14, %arg10, %arg12, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_6 = tensor.extract_slice %extracted_slice_0[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_7 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %7 = tutorial.dequant %extracted_slice_6, %extracted_slice_7 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %8 = linalg.generic {indexing_maps = [#map2, #map3, #map4], iterator_types = ["parallel", "parallel", "parallel", "parallel", "reduction", "reduction", "reduction"]} ins(%extracted_slice_5, %7 : tensor<1x1x1x64xf32>, tensor<1x1x5x1xf32>) outs(%arg15 : tensor<1x1x5x64xf32>) attrs =  {lowering_config = {parallel = [1, 1, 5, 64], reduction = [0, 0, 0, 0, 1, 1, 1]}} {
            ^bb0(%in: f32, %in_8: f32, %out: f32):
              %9 = arith.mulf %in, %in_8 : f32
              %10 = arith.addf %out, %9 : f32
              linalg.yield %10 : f32
            } -> tensor<1x1x5x64xf32>
            scf.yield %8 : tensor<1x1x5x64xf32>
          }
          scf.yield %6 : tensor<1x1x5x64xf32>
        }
        scf.yield %5 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_4 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %4 = linalg.generic {indexing_maps = [#map5, #map1, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%cst, %3 : f32, tensor<1x1x5x64xf32>) outs(%extracted_slice_4 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %in_5: f32, %out: f32):
        %5 = arith.maxnumf %in, %in_5 : f32
        linalg.yield %5 : f32
      } -> tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %4 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %1 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before LinalgFoldUnitExtentDimsPass (linalg-fold-unit-extent-dims) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d3)>
#map1 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
#map2 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d6, d4, d5, d3)>
#map3 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1 + d4, d2 + d5, d6)>
#map4 = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3)>
#map5 = affine_map<(d0, d1, d2, d3) -> ()>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = tensor.empty() : tensor<5x80x100x128xf32>
    %1 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_0 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %extracted_slice_3 = tensor.extract_slice %0[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %2 = linalg.generic {indexing_maps = [#map, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%extracted_slice_2 : tensor<64xf32>) outs(%extracted_slice_3 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %out: f32):
        linalg.yield %in : f32
      } -> tensor<1x1x5x64xf32>
      %3 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %2) -> (tensor<1x1x5x64xf32>) {
        %5 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (tensor<1x1x5x64xf32>) {
          %6 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_5 = tensor.extract_slice %extracted_slice[%arg14, %arg10, %arg12, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_6 = tensor.extract_slice %extracted_slice_0[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_7 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %7 = tutorial.dequant %extracted_slice_6, %extracted_slice_7 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %8 = linalg.generic {indexing_maps = [#map2, #map3, #map4], iterator_types = ["parallel", "parallel", "parallel", "parallel", "reduction", "reduction", "reduction"]} ins(%extracted_slice_5, %7 : tensor<1x1x1x64xf32>, tensor<1x1x5x1xf32>) outs(%arg15 : tensor<1x1x5x64xf32>) attrs =  {lowering_config = {parallel = [1, 1, 5, 64], reduction = [0, 0, 0, 0, 1, 1, 1]}} {
            ^bb0(%in: f32, %in_8: f32, %out: f32):
              %9 = arith.mulf %in, %in_8 : f32
              %10 = arith.addf %out, %9 : f32
              linalg.yield %10 : f32
            } -> tensor<1x1x5x64xf32>
            scf.yield %8 : tensor<1x1x5x64xf32>
          }
          scf.yield %6 : tensor<1x1x5x64xf32>
        }
        scf.yield %5 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_4 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %4 = linalg.generic {indexing_maps = [#map5, #map1, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%cst, %3 : f32, tensor<1x1x5x64xf32>) outs(%extracted_slice_4 : tensor<1x1x5x64xf32>) {
      ^bb0(%in: f32, %in_5: f32, %out: f32):
        %5 = arith.maxnumf %in, %in_5 : f32
        linalg.yield %5 : f32
      } -> tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %4 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %1 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump After LinalgFoldUnitExtentDimsPass (linalg-fold-unit-extent-dims) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1) -> (d1)>
#map1 = affine_map<(d0, d1) -> (d0, d1)>
#map2 = affine_map<(d0, d1) -> (d0)>
#map3 = affine_map<(d0, d1) -> ()>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_0 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %1 = tensor.empty() : tensor<1x1x5x64xf32>
      %2 = tensor.empty() : tensor<5x64xf32>
      %3 = linalg.generic {indexing_maps = [#map, #map1], iterator_types = ["parallel", "parallel"]} ins(%extracted_slice_2 : tensor<64xf32>) outs(%2 : tensor<5x64xf32>) {
      ^bb0(%in: f32, %out: f32):
        linalg.yield %in : f32
      } -> tensor<5x64xf32>
      %inserted_slice = tensor.insert_slice %3 into %1[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
      %4 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %inserted_slice) -> (tensor<1x1x5x64xf32>) {
        %6 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (tensor<1x1x5x64xf32>) {
          %7 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_7 = tensor.extract_slice %extracted_slice[%arg14, %arg10, %arg12, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_8 = tensor.extract_slice %extracted_slice_0[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_9 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %8 = tutorial.dequant %extracted_slice_8, %extracted_slice_9 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %extracted_slice_10 = tensor.extract_slice %extracted_slice_7[0, 0, 0, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<1x1x1x64xf32> to tensor<64xf32>
            %extracted_slice_11 = tensor.extract_slice %8[0, 0, 0, 0] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x1x5x1xf32> to tensor<1x5xf32>
            %extracted_slice_12 = tensor.extract_slice %arg15[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
            %9 = tensor.empty() : tensor<5x64xf32>
            %extracted_slice_13 = tensor.extract_slice %extracted_slice_11[0, 0] [1, 5] [1, 1] : tensor<1x5xf32> to tensor<5xf32>
            %10 = linalg.generic {indexing_maps = [#map, #map2, #map1, #map1], iterator_types = ["parallel", "parallel"]} ins(%extracted_slice_10, %extracted_slice_13, %extracted_slice_12 : tensor<64xf32>, tensor<5xf32>, tensor<5x64xf32>) outs(%9 : tensor<5x64xf32>) {
            ^bb0(%in: f32, %in_15: f32, %in_16: f32, %out: f32):
              %11 = arith.mulf %in, %in_15 : f32
              %12 = arith.addf %in_16, %11 : f32
              linalg.yield %12 : f32
            } -> tensor<5x64xf32>
            %inserted_slice_14 = tensor.insert_slice %10 into %arg15[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
            scf.yield %inserted_slice_14 : tensor<1x1x5x64xf32>
          }
          scf.yield %7 : tensor<1x1x5x64xf32>
        }
        scf.yield %6 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_3 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %extracted_slice_4 = tensor.extract_slice %4[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %extracted_slice_5 = tensor.extract_slice %extracted_slice_3[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %5 = linalg.generic {indexing_maps = [#map3, #map1, #map1], iterator_types = ["parallel", "parallel"]} ins(%cst, %extracted_slice_4 : f32, tensor<5x64xf32>) outs(%extracted_slice_5 : tensor<5x64xf32>) {
      ^bb0(%in: f32, %in_7: f32, %out: f32):
        %6 = arith.maxnumf %in, %in_7 : f32
        linalg.yield %6 : f32
      } -> tensor<5x64xf32>
      %inserted_slice_6 = tensor.insert_slice %5 into %extracted_slice_3[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %inserted_slice_6 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %0 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before TutorialVectorization (tutorial-vectorization) ('func.func' operation: @conv_with_dequant) //----- //
#map = affine_map<(d0, d1) -> (d1)>
#map1 = affine_map<(d0, d1) -> (d0, d1)>
#map2 = affine_map<(d0, d1) -> (d0)>
#map3 = affine_map<(d0, d1) -> ()>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_0 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %1 = tensor.empty() : tensor<1x1x5x64xf32>
      %2 = tensor.empty() : tensor<5x64xf32>
      %3 = linalg.generic {indexing_maps = [#map, #map1], iterator_types = ["parallel", "parallel"]} ins(%extracted_slice_2 : tensor<64xf32>) outs(%2 : tensor<5x64xf32>) {
      ^bb0(%in: f32, %out: f32):
        linalg.yield %in : f32
      } -> tensor<5x64xf32>
      %inserted_slice = tensor.insert_slice %3 into %1[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
      %4 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %inserted_slice) -> (tensor<1x1x5x64xf32>) {
        %6 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (tensor<1x1x5x64xf32>) {
          %7 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_7 = tensor.extract_slice %extracted_slice[%arg14, %arg10, %arg12, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_8 = tensor.extract_slice %extracted_slice_0[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_9 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %8 = tutorial.dequant %extracted_slice_8, %extracted_slice_9 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %extracted_slice_10 = tensor.extract_slice %extracted_slice_7[0, 0, 0, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<1x1x1x64xf32> to tensor<64xf32>
            %extracted_slice_11 = tensor.extract_slice %8[0, 0, 0, 0] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x1x5x1xf32> to tensor<1x5xf32>
            %extracted_slice_12 = tensor.extract_slice %arg15[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
            %9 = tensor.empty() : tensor<5x64xf32>
            %extracted_slice_13 = tensor.extract_slice %extracted_slice_11[0, 0] [1, 5] [1, 1] : tensor<1x5xf32> to tensor<5xf32>
            %10 = linalg.generic {indexing_maps = [#map, #map2, #map1, #map1], iterator_types = ["parallel", "parallel"]} ins(%extracted_slice_10, %extracted_slice_13, %extracted_slice_12 : tensor<64xf32>, tensor<5xf32>, tensor<5x64xf32>) outs(%9 : tensor<5x64xf32>) {
            ^bb0(%in: f32, %in_15: f32, %in_16: f32, %out: f32):
              %11 = arith.mulf %in, %in_15 : f32
              %12 = arith.addf %in_16, %11 : f32
              linalg.yield %12 : f32
            } -> tensor<5x64xf32>
            %inserted_slice_14 = tensor.insert_slice %10 into %arg15[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
            scf.yield %inserted_slice_14 : tensor<1x1x5x64xf32>
          }
          scf.yield %7 : tensor<1x1x5x64xf32>
        }
        scf.yield %6 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_3 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %extracted_slice_4 = tensor.extract_slice %4[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %extracted_slice_5 = tensor.extract_slice %extracted_slice_3[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %5 = linalg.generic {indexing_maps = [#map3, #map1, #map1], iterator_types = ["parallel", "parallel"]} ins(%cst, %extracted_slice_4 : f32, tensor<5x64xf32>) outs(%extracted_slice_5 : tensor<5x64xf32>) {
      ^bb0(%in: f32, %in_7: f32, %out: f32):
        %6 = arith.maxnumf %in, %in_7 : f32
        linalg.yield %6 : f32
      } -> tensor<5x64xf32>
      %inserted_slice_6 = tensor.insert_slice %5 into %extracted_slice_3[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %inserted_slice_6 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %0 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump After TutorialVectorization (tutorial-vectorization) ('func.func' operation: @conv_with_dequant) //----- //
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %cst = arith.constant dense<0.000000e+00> : vector<5x64xf32>
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_1 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_3 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %1 = tensor.empty() : tensor<1x1x5x64xf32>
      %2 = tensor.empty() : tensor<5x64xf32>
      %3 = vector.transfer_read %extracted_slice_3[%c0], %cst_0 {in_bounds = [true]} : tensor<64xf32>, vector<64xf32>
      %4 = vector.broadcast %3 : vector<64xf32> to vector<5x64xf32>
      %5 = vector.transfer_write %4, %2[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      %inserted_slice = tensor.insert_slice %5 into %1[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
      %6 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %inserted_slice) -> (tensor<1x1x5x64xf32>) {
        %10 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (tensor<1x1x5x64xf32>) {
          %11 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_8 = tensor.extract_slice %extracted_slice[%arg14, %arg10, %arg12, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_9 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_10 = tensor.extract_slice %extracted_slice_2[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %12 = tutorial.dequant %extracted_slice_9, %extracted_slice_10 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %extracted_slice_11 = tensor.extract_slice %extracted_slice_8[0, 0, 0, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<1x1x1x64xf32> to tensor<64xf32>
            %extracted_slice_12 = tensor.extract_slice %12[0, 0, 0, 0] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x1x5x1xf32> to tensor<1x5xf32>
            %extracted_slice_13 = tensor.extract_slice %arg15[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
            %13 = tensor.empty() : tensor<5x64xf32>
            %extracted_slice_14 = tensor.extract_slice %extracted_slice_12[0, 0] [1, 5] [1, 1] : tensor<1x5xf32> to tensor<5xf32>
            %14 = vector.transfer_read %extracted_slice_11[%c0], %cst_0 {in_bounds = [true]} : tensor<64xf32>, vector<64xf32>
            %15 = vector.broadcast %14 : vector<64xf32> to vector<5x64xf32>
            %16 = vector.transfer_read %extracted_slice_14[%c0], %cst_0 {in_bounds = [true]} : tensor<5xf32>, vector<5xf32>
            %17 = vector.broadcast %16 : vector<5xf32> to vector<64x5xf32>
            %18 = vector.transpose %17, [1, 0] : vector<64x5xf32> to vector<5x64xf32>
            %19 = vector.transfer_read %extracted_slice_13[%c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<5x64xf32>, vector<5x64xf32>
            %20 = arith.mulf %15, %18 : vector<5x64xf32>
            %21 = arith.addf %19, %20 : vector<5x64xf32>
            %22 = vector.transfer_write %21, %13[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
            %inserted_slice_15 = tensor.insert_slice %22 into %arg15[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
            scf.yield %inserted_slice_15 : tensor<1x1x5x64xf32>
          }
          scf.yield %11 : tensor<1x1x5x64xf32>
        }
        scf.yield %10 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_4 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %extracted_slice_5 = tensor.extract_slice %6[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %extracted_slice_6 = tensor.extract_slice %extracted_slice_4[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %7 = vector.transfer_read %extracted_slice_5[%c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<5x64xf32>, vector<5x64xf32>
      %8 = arith.maxnumf %7, %cst : vector<5x64xf32>
      %9 = vector.transfer_write %8, %extracted_slice_6[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      %inserted_slice_7 = tensor.insert_slice %9 into %extracted_slice_4[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %inserted_slice_7 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %0 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %cst = arith.constant dense<0.000000e+00> : vector<5x64xf32>
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_1 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_3 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %1 = tensor.empty() : tensor<1x1x5x64xf32>
      %2 = tensor.empty() : tensor<5x64xf32>
      %3 = vector.transfer_read %extracted_slice_3[%c0], %cst_0 {in_bounds = [true]} : tensor<64xf32>, vector<64xf32>
      %4 = vector.broadcast %3 : vector<64xf32> to vector<5x64xf32>
      %5 = vector.transfer_write %4, %2[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      %inserted_slice = tensor.insert_slice %5 into %1[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
      %6 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %inserted_slice) -> (tensor<1x1x5x64xf32>) {
        %10 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (tensor<1x1x5x64xf32>) {
          %11 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_8 = tensor.extract_slice %extracted_slice[%arg14, %arg10, %arg12, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_9 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_10 = tensor.extract_slice %extracted_slice_2[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %12 = tutorial.dequant %extracted_slice_9, %extracted_slice_10 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %extracted_slice_11 = tensor.extract_slice %extracted_slice_8[0, 0, 0, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<1x1x1x64xf32> to tensor<64xf32>
            %extracted_slice_12 = tensor.extract_slice %12[0, 0, 0, 0] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x1x5x1xf32> to tensor<1x5xf32>
            %extracted_slice_13 = tensor.extract_slice %arg15[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
            %13 = tensor.empty() : tensor<5x64xf32>
            %extracted_slice_14 = tensor.extract_slice %extracted_slice_12[0, 0] [1, 5] [1, 1] : tensor<1x5xf32> to tensor<5xf32>
            %14 = vector.transfer_read %extracted_slice_11[%c0], %cst_0 {in_bounds = [true]} : tensor<64xf32>, vector<64xf32>
            %15 = vector.broadcast %14 : vector<64xf32> to vector<5x64xf32>
            %16 = vector.transfer_read %extracted_slice_14[%c0], %cst_0 {in_bounds = [true]} : tensor<5xf32>, vector<5xf32>
            %17 = vector.broadcast %16 : vector<5xf32> to vector<64x5xf32>
            %18 = vector.transpose %17, [1, 0] : vector<64x5xf32> to vector<5x64xf32>
            %19 = vector.transfer_read %extracted_slice_13[%c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<5x64xf32>, vector<5x64xf32>
            %20 = arith.mulf %15, %18 : vector<5x64xf32>
            %21 = arith.addf %19, %20 : vector<5x64xf32>
            %22 = vector.transfer_write %21, %13[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
            %inserted_slice_15 = tensor.insert_slice %22 into %arg15[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
            scf.yield %inserted_slice_15 : tensor<1x1x5x64xf32>
          }
          scf.yield %11 : tensor<1x1x5x64xf32>
        }
        scf.yield %10 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_4 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %extracted_slice_5 = tensor.extract_slice %6[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %extracted_slice_6 = tensor.extract_slice %extracted_slice_4[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %7 = vector.transfer_read %extracted_slice_5[%c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<5x64xf32>, vector<5x64xf32>
      %8 = arith.maxnumf %7, %cst : vector<5x64xf32>
      %9 = vector.transfer_write %8, %extracted_slice_6[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      %inserted_slice_7 = tensor.insert_slice %9 into %extracted_slice_4[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %inserted_slice_7 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %0 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before CSE (cse) ('builtin.module' operation) //----- //
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %cst = arith.constant dense<0.000000e+00> : vector<5x64xf32>
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_1 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_3 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %1 = tensor.empty() : tensor<1x1x5x64xf32>
      %2 = tensor.empty() : tensor<5x64xf32>
      %3 = vector.transfer_read %extracted_slice_3[%c0], %cst_0 {in_bounds = [true]} : tensor<64xf32>, vector<64xf32>
      %4 = vector.broadcast %3 : vector<64xf32> to vector<5x64xf32>
      %5 = vector.transfer_write %4, %2[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      %inserted_slice = tensor.insert_slice %5 into %1[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
      %6 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %inserted_slice) -> (tensor<1x1x5x64xf32>) {
        %10 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (tensor<1x1x5x64xf32>) {
          %11 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_8 = tensor.extract_slice %extracted_slice[%arg14, %arg10, %arg12, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_9 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_10 = tensor.extract_slice %extracted_slice_2[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %12 = tutorial.dequant %extracted_slice_9, %extracted_slice_10 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %extracted_slice_11 = tensor.extract_slice %extracted_slice_8[0, 0, 0, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<1x1x1x64xf32> to tensor<64xf32>
            %extracted_slice_12 = tensor.extract_slice %12[0, 0, 0, 0] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x1x5x1xf32> to tensor<1x5xf32>
            %extracted_slice_13 = tensor.extract_slice %arg15[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
            %13 = tensor.empty() : tensor<5x64xf32>
            %extracted_slice_14 = tensor.extract_slice %extracted_slice_12[0, 0] [1, 5] [1, 1] : tensor<1x5xf32> to tensor<5xf32>
            %14 = vector.transfer_read %extracted_slice_11[%c0], %cst_0 {in_bounds = [true]} : tensor<64xf32>, vector<64xf32>
            %15 = vector.broadcast %14 : vector<64xf32> to vector<5x64xf32>
            %16 = vector.transfer_read %extracted_slice_14[%c0], %cst_0 {in_bounds = [true]} : tensor<5xf32>, vector<5xf32>
            %17 = vector.broadcast %16 : vector<5xf32> to vector<64x5xf32>
            %18 = vector.transpose %17, [1, 0] : vector<64x5xf32> to vector<5x64xf32>
            %19 = vector.transfer_read %extracted_slice_13[%c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<5x64xf32>, vector<5x64xf32>
            %20 = arith.mulf %15, %18 : vector<5x64xf32>
            %21 = arith.addf %19, %20 : vector<5x64xf32>
            %22 = vector.transfer_write %21, %13[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
            %inserted_slice_15 = tensor.insert_slice %22 into %arg15[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
            scf.yield %inserted_slice_15 : tensor<1x1x5x64xf32>
          }
          scf.yield %11 : tensor<1x1x5x64xf32>
        }
        scf.yield %10 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_4 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %extracted_slice_5 = tensor.extract_slice %6[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %extracted_slice_6 = tensor.extract_slice %extracted_slice_4[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %7 = vector.transfer_read %extracted_slice_5[%c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<5x64xf32>, vector<5x64xf32>
      %8 = arith.maxnumf %7, %cst : vector<5x64xf32>
      %9 = vector.transfer_write %8, %extracted_slice_6[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      %inserted_slice_7 = tensor.insert_slice %9 into %extracted_slice_4[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %inserted_slice_7 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %0 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump After CSE (cse) ('builtin.module' operation) //----- //
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %cst = arith.constant dense<0.000000e+00> : vector<5x64xf32>
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_1 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_3 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %1 = tensor.empty() : tensor<1x1x5x64xf32>
      %2 = tensor.empty() : tensor<5x64xf32>
      %3 = vector.transfer_read %extracted_slice_3[%c0], %cst_0 {in_bounds = [true]} : tensor<64xf32>, vector<64xf32>
      %4 = vector.broadcast %3 : vector<64xf32> to vector<5x64xf32>
      %5 = vector.transfer_write %4, %2[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      %inserted_slice = tensor.insert_slice %5 into %1[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
      %6 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %inserted_slice) -> (tensor<1x1x5x64xf32>) {
        %10 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (tensor<1x1x5x64xf32>) {
          %11 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_8 = tensor.extract_slice %extracted_slice[%arg14, %arg10, %arg12, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_9 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_10 = tensor.extract_slice %extracted_slice_2[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %12 = tutorial.dequant %extracted_slice_9, %extracted_slice_10 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %extracted_slice_11 = tensor.extract_slice %extracted_slice_8[0, 0, 0, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<1x1x1x64xf32> to tensor<64xf32>
            %extracted_slice_12 = tensor.extract_slice %12[0, 0, 0, 0] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x1x5x1xf32> to tensor<1x5xf32>
            %extracted_slice_13 = tensor.extract_slice %arg15[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
            %extracted_slice_14 = tensor.extract_slice %extracted_slice_12[0, 0] [1, 5] [1, 1] : tensor<1x5xf32> to tensor<5xf32>
            %13 = vector.transfer_read %extracted_slice_11[%c0], %cst_0 {in_bounds = [true]} : tensor<64xf32>, vector<64xf32>
            %14 = vector.broadcast %13 : vector<64xf32> to vector<5x64xf32>
            %15 = vector.transfer_read %extracted_slice_14[%c0], %cst_0 {in_bounds = [true]} : tensor<5xf32>, vector<5xf32>
            %16 = vector.broadcast %15 : vector<5xf32> to vector<64x5xf32>
            %17 = vector.transpose %16, [1, 0] : vector<64x5xf32> to vector<5x64xf32>
            %18 = vector.transfer_read %extracted_slice_13[%c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<5x64xf32>, vector<5x64xf32>
            %19 = arith.mulf %14, %17 : vector<5x64xf32>
            %20 = arith.addf %18, %19 : vector<5x64xf32>
            %21 = vector.transfer_write %20, %2[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
            %inserted_slice_15 = tensor.insert_slice %21 into %arg15[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
            scf.yield %inserted_slice_15 : tensor<1x1x5x64xf32>
          }
          scf.yield %11 : tensor<1x1x5x64xf32>
        }
        scf.yield %10 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_4 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %extracted_slice_5 = tensor.extract_slice %6[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %extracted_slice_6 = tensor.extract_slice %extracted_slice_4[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %7 = vector.transfer_read %extracted_slice_5[%c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<5x64xf32>, vector<5x64xf32>
      %8 = arith.maxnumf %7, %cst : vector<5x64xf32>
      %9 = vector.transfer_write %8, %extracted_slice_6[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      %inserted_slice_7 = tensor.insert_slice %9 into %extracted_slice_4[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %inserted_slice_7 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %0 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before FoldTensorSubsetOps (fold-tensor-subset-ops) ('builtin.module' operation) //----- //
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %cst = arith.constant dense<0.000000e+00> : vector<5x64xf32>
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg2[0, 0, 0, %arg8] [128, 3, 3, 64] [1, 1, 1, 1] : tensor<128x3x3x128xf32> to tensor<128x3x3x64xf32>
      %extracted_slice_1 = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_2 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_3 = tensor.extract_slice %arg3[%arg8] [64] [1] : tensor<128xf32> to tensor<64xf32>
      %1 = tensor.empty() : tensor<1x1x5x64xf32>
      %2 = tensor.empty() : tensor<5x64xf32>
      %3 = vector.transfer_read %extracted_slice_3[%c0], %cst_0 {in_bounds = [true]} : tensor<64xf32>, vector<64xf32>
      %4 = vector.broadcast %3 : vector<64xf32> to vector<5x64xf32>
      %5 = vector.transfer_write %4, %2[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      %inserted_slice = tensor.insert_slice %5 into %1[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
      %6 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %inserted_slice) -> (tensor<1x1x5x64xf32>) {
        %10 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (tensor<1x1x5x64xf32>) {
          %11 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_8 = tensor.extract_slice %extracted_slice[%arg14, %arg10, %arg12, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<128x3x3x64xf32> to tensor<1x1x1x64xf32>
            %extracted_slice_9 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_10 = tensor.extract_slice %extracted_slice_2[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %12 = tutorial.dequant %extracted_slice_9, %extracted_slice_10 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %extracted_slice_11 = tensor.extract_slice %extracted_slice_8[0, 0, 0, 0] [1, 1, 1, 64] [1, 1, 1, 1] : tensor<1x1x1x64xf32> to tensor<64xf32>
            %extracted_slice_12 = tensor.extract_slice %12[0, 0, 0, 0] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x1x5x1xf32> to tensor<1x5xf32>
            %extracted_slice_13 = tensor.extract_slice %arg15[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
            %extracted_slice_14 = tensor.extract_slice %extracted_slice_12[0, 0] [1, 5] [1, 1] : tensor<1x5xf32> to tensor<5xf32>
            %13 = vector.transfer_read %extracted_slice_11[%c0], %cst_0 {in_bounds = [true]} : tensor<64xf32>, vector<64xf32>
            %14 = vector.broadcast %13 : vector<64xf32> to vector<5x64xf32>
            %15 = vector.transfer_read %extracted_slice_14[%c0], %cst_0 {in_bounds = [true]} : tensor<5xf32>, vector<5xf32>
            %16 = vector.broadcast %15 : vector<5xf32> to vector<64x5xf32>
            %17 = vector.transpose %16, [1, 0] : vector<64x5xf32> to vector<5x64xf32>
            %18 = vector.transfer_read %extracted_slice_13[%c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<5x64xf32>, vector<5x64xf32>
            %19 = arith.mulf %14, %17 : vector<5x64xf32>
            %20 = arith.addf %18, %19 : vector<5x64xf32>
            %21 = vector.transfer_write %20, %2[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
            %inserted_slice_15 = tensor.insert_slice %21 into %arg15[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
            scf.yield %inserted_slice_15 : tensor<1x1x5x64xf32>
          }
          scf.yield %11 : tensor<1x1x5x64xf32>
        }
        scf.yield %10 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_4 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %extracted_slice_5 = tensor.extract_slice %6[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %extracted_slice_6 = tensor.extract_slice %extracted_slice_4[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %7 = vector.transfer_read %extracted_slice_5[%c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<5x64xf32>, vector<5x64xf32>
      %8 = arith.maxnumf %7, %cst : vector<5x64xf32>
      %9 = vector.transfer_write %8, %extracted_slice_6[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      %inserted_slice_7 = tensor.insert_slice %9 into %extracted_slice_4[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<1x1x5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %inserted_slice_7 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %0 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump After FoldTensorSubsetOps (fold-tensor-subset-ops) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d2)>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %cst = arith.constant dense<0.000000e+00> : vector<5x64xf32>
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %1 = tensor.empty() : tensor<1x1x5x64xf32>
      %2 = vector.transfer_read %arg3[%arg8], %cst_0 {in_bounds = [true]} : tensor<128xf32>, vector<64xf32>
      %3 = vector.broadcast %2 : vector<64xf32> to vector<5x64xf32>
      %4 = vector.transfer_write %3, %1[%c0, %c0, %c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<1x1x5x64xf32>
      %5 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %4) -> (tensor<1x1x5x64xf32>) {
        %9 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (tensor<1x1x5x64xf32>) {
          %10 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_4 = tensor.extract_slice %extracted_slice[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_5 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %11 = tutorial.dequant %extracted_slice_4, %extracted_slice_5 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %12 = vector.transfer_read %arg2[%arg14, %arg10, %arg12, %arg8], %cst_0 {in_bounds = [true]} : tensor<128x3x3x128xf32>, vector<64xf32>
            %13 = vector.broadcast %12 : vector<64xf32> to vector<5x64xf32>
            %14 = vector.transfer_read %11[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true], permutation_map = #map} : tensor<1x1x5x1xf32>, vector<5xf32>
            %15 = vector.broadcast %14 : vector<5xf32> to vector<64x5xf32>
            %16 = vector.transpose %15, [1, 0] : vector<64x5xf32> to vector<5x64xf32>
            %17 = vector.transfer_read %arg15[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<1x1x5x64xf32>, vector<5x64xf32>
            %18 = arith.mulf %13, %16 : vector<5x64xf32>
            %19 = arith.addf %17, %18 : vector<5x64xf32>
            %20 = vector.transfer_write %19, %arg15[%c0, %c0, %c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<1x1x5x64xf32>
            scf.yield %20 : tensor<1x1x5x64xf32>
          }
          scf.yield %10 : tensor<1x1x5x64xf32>
        }
        scf.yield %9 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_2 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %extracted_slice_3 = tensor.extract_slice %extracted_slice_2[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %6 = vector.transfer_read %5[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<1x1x5x64xf32>, vector<5x64xf32>
      %7 = arith.maxnumf %6, %cst : vector<5x64xf32>
      %8 = vector.transfer_write %7, %extracted_slice_3[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %8 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %0 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before LoopInvariantSubsetHoisting (loop-invariant-subset-hoisting) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d2)>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %cst = arith.constant dense<0.000000e+00> : vector<5x64xf32>
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %1 = tensor.empty() : tensor<1x1x5x64xf32>
      %2 = vector.transfer_read %arg3[%arg8], %cst_0 {in_bounds = [true]} : tensor<128xf32>, vector<64xf32>
      %3 = vector.broadcast %2 : vector<64xf32> to vector<5x64xf32>
      %4 = vector.transfer_write %3, %1[%c0, %c0, %c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<1x1x5x64xf32>
      %5 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %4) -> (tensor<1x1x5x64xf32>) {
        %9 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (tensor<1x1x5x64xf32>) {
          %10 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (tensor<1x1x5x64xf32>) {
            %extracted_slice_4 = tensor.extract_slice %extracted_slice[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_5 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %11 = tutorial.dequant %extracted_slice_4, %extracted_slice_5 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %12 = vector.transfer_read %arg2[%arg14, %arg10, %arg12, %arg8], %cst_0 {in_bounds = [true]} : tensor<128x3x3x128xf32>, vector<64xf32>
            %13 = vector.broadcast %12 : vector<64xf32> to vector<5x64xf32>
            %14 = vector.transfer_read %11[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true], permutation_map = #map} : tensor<1x1x5x1xf32>, vector<5xf32>
            %15 = vector.broadcast %14 : vector<5xf32> to vector<64x5xf32>
            %16 = vector.transpose %15, [1, 0] : vector<64x5xf32> to vector<5x64xf32>
            %17 = vector.transfer_read %arg15[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<1x1x5x64xf32>, vector<5x64xf32>
            %18 = arith.mulf %13, %16 : vector<5x64xf32>
            %19 = arith.addf %17, %18 : vector<5x64xf32>
            %20 = vector.transfer_write %19, %arg15[%c0, %c0, %c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<1x1x5x64xf32>
            scf.yield %20 : tensor<1x1x5x64xf32>
          }
          scf.yield %10 : tensor<1x1x5x64xf32>
        }
        scf.yield %9 : tensor<1x1x5x64xf32>
      }
      %extracted_slice_2 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %extracted_slice_3 = tensor.extract_slice %extracted_slice_2[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %6 = vector.transfer_read %5[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<1x1x5x64xf32>, vector<5x64xf32>
      %7 = arith.maxnumf %6, %cst : vector<5x64xf32>
      %8 = vector.transfer_write %7, %extracted_slice_3[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %8 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %0 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump After LoopInvariantSubsetHoisting (loop-invariant-subset-hoisting) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d2)>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %cst = arith.constant dense<0.000000e+00> : vector<5x64xf32>
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %1 = tensor.empty() : tensor<1x1x5x64xf32>
      %2 = vector.transfer_read %arg3[%arg8], %cst_0 {in_bounds = [true]} : tensor<128xf32>, vector<64xf32>
      %3 = vector.broadcast %2 : vector<64xf32> to vector<5x64xf32>
      %4 = vector.transfer_write %3, %1[%c0, %c0, %c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<1x1x5x64xf32>
      %5 = vector.transfer_read %4[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<1x1x5x64xf32>, vector<5x64xf32>
      %6:2 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %4, %arg12 = %5) -> (tensor<1x1x5x64xf32>, vector<5x64xf32>) {
        %11:2 = scf.for %arg13 = %c0 to %c3 step %c1 iter_args(%arg14 = %arg11, %arg15 = %arg12) -> (tensor<1x1x5x64xf32>, vector<5x64xf32>) {
          %12:2 = scf.for %arg16 = %c0 to %c128 step %c1 iter_args(%arg17 = %arg14, %arg18 = %arg15) -> (tensor<1x1x5x64xf32>, vector<5x64xf32>) {
            %extracted_slice_4 = tensor.extract_slice %extracted_slice[0, %arg10, %arg13, %arg16] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_5 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg13, %arg16] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %13 = tutorial.dequant %extracted_slice_4, %extracted_slice_5 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %14 = vector.transfer_read %arg2[%arg16, %arg10, %arg13, %arg8], %cst_0 {in_bounds = [true]} : tensor<128x3x3x128xf32>, vector<64xf32>
            %15 = vector.broadcast %14 : vector<64xf32> to vector<5x64xf32>
            %16 = vector.transfer_read %13[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true], permutation_map = #map} : tensor<1x1x5x1xf32>, vector<5xf32>
            %17 = vector.broadcast %16 : vector<5xf32> to vector<64x5xf32>
            %18 = vector.transpose %17, [1, 0] : vector<64x5xf32> to vector<5x64xf32>
            %19 = arith.mulf %15, %18 : vector<5x64xf32>
            %20 = arith.addf %arg18, %19 : vector<5x64xf32>
            scf.yield %arg17, %20 : tensor<1x1x5x64xf32>, vector<5x64xf32>
          }
          scf.yield %12#0, %12#1 : tensor<1x1x5x64xf32>, vector<5x64xf32>
        }
        scf.yield %11#0, %11#1 : tensor<1x1x5x64xf32>, vector<5x64xf32>
      }
      %7 = vector.transfer_write %6#1, %6#0[%c0, %c0, %c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<1x1x5x64xf32>
      %extracted_slice_2 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %extracted_slice_3 = tensor.extract_slice %extracted_slice_2[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %8 = vector.transfer_read %7[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<1x1x5x64xf32>, vector<5x64xf32>
      %9 = arith.maxnumf %8, %cst : vector<5x64xf32>
      %10 = vector.transfer_write %9, %extracted_slice_3[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %10 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %0 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d2)>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %cst = arith.constant dense<0.000000e+00> : vector<5x64xf32>
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %1 = tensor.empty() : tensor<1x1x5x64xf32>
      %2 = vector.transfer_read %arg3[%arg8], %cst_0 {in_bounds = [true]} : tensor<128xf32>, vector<64xf32>
      %3 = vector.broadcast %2 : vector<64xf32> to vector<5x64xf32>
      %4 = vector.transfer_write %3, %1[%c0, %c0, %c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<1x1x5x64xf32>
      %5 = vector.transfer_read %4[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<1x1x5x64xf32>, vector<5x64xf32>
      %6:2 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %4, %arg12 = %5) -> (tensor<1x1x5x64xf32>, vector<5x64xf32>) {
        %11:2 = scf.for %arg13 = %c0 to %c3 step %c1 iter_args(%arg14 = %arg11, %arg15 = %arg12) -> (tensor<1x1x5x64xf32>, vector<5x64xf32>) {
          %12:2 = scf.for %arg16 = %c0 to %c128 step %c1 iter_args(%arg17 = %arg14, %arg18 = %arg15) -> (tensor<1x1x5x64xf32>, vector<5x64xf32>) {
            %extracted_slice_4 = tensor.extract_slice %extracted_slice[0, %arg10, %arg13, %arg16] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_5 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg13, %arg16] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %13 = tutorial.dequant %extracted_slice_4, %extracted_slice_5 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %14 = vector.transfer_read %arg2[%arg16, %arg10, %arg13, %arg8], %cst_0 {in_bounds = [true]} : tensor<128x3x3x128xf32>, vector<64xf32>
            %15 = vector.broadcast %14 : vector<64xf32> to vector<5x64xf32>
            %16 = vector.transfer_read %13[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true], permutation_map = #map} : tensor<1x1x5x1xf32>, vector<5xf32>
            %17 = vector.broadcast %16 : vector<5xf32> to vector<64x5xf32>
            %18 = vector.transpose %17, [1, 0] : vector<64x5xf32> to vector<5x64xf32>
            %19 = arith.mulf %15, %18 : vector<5x64xf32>
            %20 = arith.addf %arg18, %19 : vector<5x64xf32>
            scf.yield %arg17, %20 : tensor<1x1x5x64xf32>, vector<5x64xf32>
          }
          scf.yield %12#0, %12#1 : tensor<1x1x5x64xf32>, vector<5x64xf32>
        }
        scf.yield %11#0, %11#1 : tensor<1x1x5x64xf32>, vector<5x64xf32>
      }
      %7 = vector.transfer_write %6#1, %6#0[%c0, %c0, %c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<1x1x5x64xf32>
      %extracted_slice_2 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %extracted_slice_3 = tensor.extract_slice %extracted_slice_2[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %8 = vector.transfer_read %7[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<1x1x5x64xf32>, vector<5x64xf32>
      %9 = arith.maxnumf %8, %cst : vector<5x64xf32>
      %10 = vector.transfer_write %9, %extracted_slice_3[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %10 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %0 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d2)>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %cst = arith.constant dense<0.000000e+00> : vector<5x64xf32>
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %1 = vector.transfer_read %arg3[%arg8], %cst_0 {in_bounds = [true]} : tensor<128xf32>, vector<64xf32>
      %2 = vector.broadcast %1 : vector<64xf32> to vector<5x64xf32>
      %3 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %2) -> (vector<5x64xf32>) {
        %6 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (vector<5x64xf32>) {
          %7 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (vector<5x64xf32>) {
            %extracted_slice_4 = tensor.extract_slice %extracted_slice[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_5 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %8 = tutorial.dequant %extracted_slice_4, %extracted_slice_5 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %9 = vector.transfer_read %arg2[%arg14, %arg10, %arg12, %arg8], %cst_0 {in_bounds = [true]} : tensor<128x3x3x128xf32>, vector<64xf32>
            %10 = vector.broadcast %9 : vector<64xf32> to vector<5x64xf32>
            %11 = vector.transfer_read %8[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true], permutation_map = #map} : tensor<1x1x5x1xf32>, vector<5xf32>
            %12 = vector.broadcast %11 : vector<5xf32> to vector<64x5xf32>
            %13 = vector.transpose %12, [1, 0] : vector<64x5xf32> to vector<5x64xf32>
            %14 = arith.mulf %10, %13 : vector<5x64xf32>
            %15 = arith.addf %arg15, %14 : vector<5x64xf32>
            scf.yield %15 : vector<5x64xf32>
          }
          scf.yield %7 : vector<5x64xf32>
        }
        scf.yield %6 : vector<5x64xf32>
      }
      %extracted_slice_2 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %extracted_slice_3 = tensor.extract_slice %extracted_slice_2[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %4 = arith.maxnumf %3, %cst : vector<5x64xf32>
      %5 = vector.transfer_write %4, %extracted_slice_3[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %5 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %0 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before CSE (cse) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d2)>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %cst = arith.constant dense<0.000000e+00> : vector<5x64xf32>
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %1 = vector.transfer_read %arg3[%arg8], %cst_0 {in_bounds = [true]} : tensor<128xf32>, vector<64xf32>
      %2 = vector.broadcast %1 : vector<64xf32> to vector<5x64xf32>
      %3 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %2) -> (vector<5x64xf32>) {
        %6 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (vector<5x64xf32>) {
          %7 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (vector<5x64xf32>) {
            %extracted_slice_4 = tensor.extract_slice %extracted_slice[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_5 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %8 = tutorial.dequant %extracted_slice_4, %extracted_slice_5 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %9 = vector.transfer_read %arg2[%arg14, %arg10, %arg12, %arg8], %cst_0 {in_bounds = [true]} : tensor<128x3x3x128xf32>, vector<64xf32>
            %10 = vector.broadcast %9 : vector<64xf32> to vector<5x64xf32>
            %11 = vector.transfer_read %8[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true], permutation_map = #map} : tensor<1x1x5x1xf32>, vector<5xf32>
            %12 = vector.broadcast %11 : vector<5xf32> to vector<64x5xf32>
            %13 = vector.transpose %12, [1, 0] : vector<64x5xf32> to vector<5x64xf32>
            %14 = arith.mulf %10, %13 : vector<5x64xf32>
            %15 = arith.addf %arg15, %14 : vector<5x64xf32>
            scf.yield %15 : vector<5x64xf32>
          }
          scf.yield %7 : vector<5x64xf32>
        }
        scf.yield %6 : vector<5x64xf32>
      }
      %extracted_slice_2 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %extracted_slice_3 = tensor.extract_slice %extracted_slice_2[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %4 = arith.maxnumf %3, %cst : vector<5x64xf32>
      %5 = vector.transfer_write %4, %extracted_slice_3[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %5 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %0 : tensor<5x80x100x128xf32>
  }
}


// -----// IR Dump Before OneShotBufferize (one-shot-bufferize) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d2)>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %cst = arith.constant dense<0.000000e+00> : vector<5x64xf32>
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) shared_outs(%arg9 = %arg4) -> (tensor<5x80x100x128xf32>) {
      %extracted_slice = tensor.extract_slice %arg0[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %extracted_slice_1 = tensor.extract_slice %arg1[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : tensor<5x82x102x128xf32> to tensor<1x3x7x128xf32>
      %1 = vector.transfer_read %arg3[%arg8], %cst_0 {in_bounds = [true]} : tensor<128xf32>, vector<64xf32>
      %2 = vector.broadcast %1 : vector<64xf32> to vector<5x64xf32>
      %3 = scf.for %arg10 = %c0 to %c3 step %c1 iter_args(%arg11 = %2) -> (vector<5x64xf32>) {
        %6 = scf.for %arg12 = %c0 to %c3 step %c1 iter_args(%arg13 = %arg11) -> (vector<5x64xf32>) {
          %7 = scf.for %arg14 = %c0 to %c128 step %c1 iter_args(%arg15 = %arg13) -> (vector<5x64xf32>) {
            %extracted_slice_4 = tensor.extract_slice %extracted_slice[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %extracted_slice_5 = tensor.extract_slice %extracted_slice_1[0, %arg10, %arg12, %arg14] [1, 1, 5, 1] [1, 1, 1, 1] : tensor<1x3x7x128xf32> to tensor<1x1x5x1xf32>
            %8 = tutorial.dequant %extracted_slice_4, %extracted_slice_5 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %9 = vector.transfer_read %arg2[%arg14, %arg10, %arg12, %arg8], %cst_0 {in_bounds = [true]} : tensor<128x3x3x128xf32>, vector<64xf32>
            %10 = vector.broadcast %9 : vector<64xf32> to vector<5x64xf32>
            %11 = vector.transfer_read %8[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true], permutation_map = #map} : tensor<1x1x5x1xf32>, vector<5xf32>
            %12 = vector.broadcast %11 : vector<5xf32> to vector<64x5xf32>
            %13 = vector.transpose %12, [1, 0] : vector<64x5xf32> to vector<5x64xf32>
            %14 = arith.mulf %10, %13 : vector<5x64xf32>
            %15 = arith.addf %arg15, %14 : vector<5x64xf32>
            scf.yield %15 : vector<5x64xf32>
          }
          scf.yield %7 : vector<5x64xf32>
        }
        scf.yield %6 : vector<5x64xf32>
      }
      %extracted_slice_2 = tensor.extract_slice %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x80x100x128xf32> to tensor<1x1x5x64xf32>
      %extracted_slice_3 = tensor.extract_slice %extracted_slice_2[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<1x1x5x64xf32> to tensor<5x64xf32>
      %4 = arith.maxnumf %3, %cst : vector<5x64xf32>
      %5 = vector.transfer_write %4, %extracted_slice_3[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, tensor<5x64xf32>
      scf.forall.in_parallel {
        tensor.parallel_insert_slice %5 into %arg9[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : tensor<5x64xf32> into tensor<5x80x100x128xf32>
      }
    }
    return %0 : tensor<5x80x100x128xf32>
  }
}


example-tutorial.mlir:29:26: error: op was not bufferized
    %input_dequantized = tutorial.dequant %input_quant, %input_scale 
                         ^
example-tutorial.mlir:29:26: note: see current operation: %28 = "tutorial.dequant"(%25, %27) : (tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>) -> tensor<1x1x5x1xf32>
// -----// IR Dump After OneShotBufferize Failed (one-shot-bufferize) ('builtin.module' operation) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d2)>
module {
  func.func @conv_with_dequant(%arg0: tensor<5x82x102x128xf32>, %arg1: tensor<5x82x102x128xf32>, %arg2: tensor<128x3x3x128xf32>, %arg3: tensor<128xf32>, %arg4: tensor<5x80x100x128xf32>) -> tensor<5x80x100x128xf32> {
    %0 = bufferization.to_memref %arg2 : memref<128x3x3x128xf32, strided<[?, ?, ?, ?], offset: ?>>
    %1 = bufferization.to_memref %arg3 : memref<128xf32, strided<[?], offset: ?>>
    %2 = bufferization.to_memref %arg1 : memref<5x82x102x128xf32, strided<[?, ?, ?, ?], offset: ?>>
    %3 = bufferization.to_memref %arg0 : memref<5x82x102x128xf32, strided<[?, ?, ?, ?], offset: ?>>
    %4 = bufferization.to_memref %arg4 : memref<5x80x100x128xf32, strided<[?, ?, ?, ?], offset: ?>>
    %cst = arith.constant dense<0.000000e+00> : vector<5x64xf32>
    %c1 = arith.constant 1 : index
    %c128 = arith.constant 128 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %alloc = memref.alloc() {alignment = 64 : i64} : memref<5x80x100x128xf32>
    memref.copy %4, %alloc : memref<5x80x100x128xf32, strided<[?, ?, ?, ?], offset: ?>> to memref<5x80x100x128xf32>
    scf.forall (%arg5, %arg6, %arg7, %arg8) = (0, 0, 0, 0) to (5, 80, 100, 128) step (1, 1, 5, 64) {
      %subview = memref.subview %3[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : memref<5x82x102x128xf32, strided<[?, ?, ?, ?], offset: ?>> to memref<1x3x7x128xf32, strided<[?, ?, ?, ?], offset: ?>>
      %subview_1 = memref.subview %2[%arg5, %arg6, %arg7, 0] [1, 3, 7, 128] [1, 1, 1, 1] : memref<5x82x102x128xf32, strided<[?, ?, ?, ?], offset: ?>> to memref<1x3x7x128xf32, strided<[?, ?, ?, ?], offset: ?>>
      %6 = vector.transfer_read %1[%arg8], %cst_0 {in_bounds = [true]} : memref<128xf32, strided<[?], offset: ?>>, vector<64xf32>
      %7 = vector.broadcast %6 : vector<64xf32> to vector<5x64xf32>
      %8 = scf.for %arg9 = %c0 to %c3 step %c1 iter_args(%arg10 = %7) -> (vector<5x64xf32>) {
        %10 = scf.for %arg11 = %c0 to %c3 step %c1 iter_args(%arg12 = %arg10) -> (vector<5x64xf32>) {
          %11 = scf.for %arg13 = %c0 to %c128 step %c1 iter_args(%arg14 = %arg12) -> (vector<5x64xf32>) {
            %subview_5 = memref.subview %subview[0, %arg9, %arg11, %arg13] [1, 1, 5, 1] [1, 1, 1, 1] : memref<1x3x7x128xf32, strided<[?, ?, ?, ?], offset: ?>> to memref<1x1x5x1xf32, strided<[?, ?, ?, ?], offset: ?>>
            %12 = bufferization.to_tensor %subview_5 : memref<1x1x5x1xf32, strided<[?, ?, ?, ?], offset: ?>>
            %subview_6 = memref.subview %subview_1[0, %arg9, %arg11, %arg13] [1, 1, 5, 1] [1, 1, 1, 1] : memref<1x3x7x128xf32, strided<[?, ?, ?, ?], offset: ?>> to memref<1x1x5x1xf32, strided<[?, ?, ?, ?], offset: ?>>
            %13 = bufferization.to_tensor %subview_6 : memref<1x1x5x1xf32, strided<[?, ?, ?, ?], offset: ?>>
            %14 = tutorial.dequant %12, %13 : tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>, tensor<1x1x5x1xf32>
            %15 = bufferization.to_memref %14 : memref<1x1x5x1xf32, strided<[?, ?, ?, ?], offset: ?>>
            %16 = vector.transfer_read %0[%arg13, %arg9, %arg11, %arg8], %cst_0 {in_bounds = [true]} : memref<128x3x3x128xf32, strided<[?, ?, ?, ?], offset: ?>>, vector<64xf32>
            %17 = vector.broadcast %16 : vector<64xf32> to vector<5x64xf32>
            %18 = vector.transfer_read %15[%c0, %c0, %c0, %c0], %cst_0 {in_bounds = [true], permutation_map = #map} : memref<1x1x5x1xf32, strided<[?, ?, ?, ?], offset: ?>>, vector<5xf32>
            %19 = vector.broadcast %18 : vector<5xf32> to vector<64x5xf32>
            %20 = vector.transpose %19, [1, 0] : vector<64x5xf32> to vector<5x64xf32>
            %21 = arith.mulf %17, %20 : vector<5x64xf32>
            %22 = arith.addf %arg14, %21 : vector<5x64xf32>
            scf.yield %22 : vector<5x64xf32>
          }
          scf.yield %11 : vector<5x64xf32>
        }
        scf.yield %10 : vector<5x64xf32>
      }
      %subview_2 = memref.subview %alloc[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : memref<5x80x100x128xf32> to memref<1x1x5x64xf32, strided<[1024000, 12800, 128, 1], offset: ?>>
      %subview_3 = memref.subview %subview_2[0, 0, 0, 0] [1, 1, 5, 64] [1, 1, 1, 1] : memref<1x1x5x64xf32, strided<[1024000, 12800, 128, 1], offset: ?>> to memref<5x64xf32, strided<[128, 1], offset: ?>>
      %9 = arith.maxnumf %8, %cst : vector<5x64xf32>
      vector.transfer_write %9, %subview_3[%c0, %c0] {in_bounds = [true, true]} : vector<5x64xf32>, memref<5x64xf32, strided<[128, 1], offset: ?>>
      %subview_4 = memref.subview %alloc[%arg5, %arg6, %arg7, %arg8] [1, 1, 5, 64] [1, 1, 1, 1] : memref<5x80x100x128xf32> to memref<5x64xf32, strided<[128, 1], offset: ?>>
      memref.copy %subview_3, %subview_4 : memref<5x64xf32, strided<[128, 1], offset: ?>> to memref<5x64xf32, strided<[128, 1], offset: ?>>
    }
    %5 = bufferization.to_tensor %alloc : memref<5x80x100x128xf32>
    return %5 : tensor<5x80x100x128xf32>
  }
}


